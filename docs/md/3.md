# Testing

_Testing_ is a crucial part of the software development process. It involves evaluating a system or its components to determine whether they meet specified requirements and function correctly.

\vspace{0.5cm}

Main concepts in testing include:

- **Validation:** It ensures that the right product is built and that it fulfills its intended purpose.
- **Verification:** It ensures that the product is built correctly and that it adheres to the specified design and implementation standards.

\vspace{0.5cm}

In testing terminology, it is useful to distinguish between the following terms:

- **Failure:** The inability of a system or component to perform its required functions within specified performance requirements.
- **Bug:** An error in a software program that causes it to produce an incorrect or unexpected result or to behave in unintended ways.
- **Error:** A human action that produces an incorrect result.

## Static Analysis

_Static analysis_ is the examination of code without executing it, aiming to identify potential errors, code quality issues, or violations of coding standards early in the development process. Most static analysis tools perform the following checks:

- **Lexical Analysis:** Checks the source code for correct use of tokens such as keywords, identifiers, operators, and punctuation. It ensures that the code adheres to the basic syntax rules of the programming language.
- **Syntax Analysis:** Examines the structure of the code to ensure it follows the grammatical rules of the language. It detects issues like missing brackets, incorrect nesting, or invalid statement structures.
- **Type Checking:** Verifies that operations in the code are performed on compatible data types, helping to catch type-related errors before execution.

## Data Flow Analysis

_Data Flow Analysis_ is a technique used to examine the flow of data within a program. It helps identify potential issues related to variable usage, data dependencies, and control flow.

\vspace{0.5cm}

In this context, we define three key concepts:

- **Definition:** The point in the program where a variable is assigned a value.
- **Usage:** The point in the program where a variable's value is accessed or utilized.
- **Kill:** Identify any misconceptions, outdated information, or common pitfalls related to the concept.

\vspace{0.5cm}

To represent data flow in a program, we need to define the following components:

To represent data flow in a program mathematically, we define the following components:

- **Alphabet ($\Sigma$):** $\Sigma = \{ D, U, K, \epsilon \}$, where $D$ = Definition, $U$ = Usage, $K$ = Kill, and $\epsilon$ = empty string.
- **Regular Expressions ($\mathcal{R}$):**
    - Every symbol $a \in \Sigma$ is a regular expression.
    - If $E_1, E_2 \in \mathcal{R}$, then:
        - $(E_1 + E_2)$ (alternation) is a regular expression.
        - $(E_1 E_2)$ (concatenation) is a regular expression.
    - If $E \in \mathcal{R}$, then $(E^*)$ (Kleene star) is a regular expression.
- **Control Flow Constructs:**
    - **Conditionals:** For a variable $x$, let $E_c$ be the regular expression for the condition, $E_{then}$ for the "then" branch, and $E_{else}$ for the "else" branch. The control flow is represented as:

        $$
        E_c \cdot (E_{then} + E_{else})
        $$
    - **Loops:** For a variable $x$, let $E_c$ be the regular expression for the loop condition and $E$ for the loop body. The control flow is represented as:

        $$
        E_c \cdot (E \cdot E_c)^*
        $$

## Structural Testing

_Structural testing_, also known as _White-Box Testing_ or glass-box testing, is a software testing technique that focuses on the internal structure and logic of the code. It involves designing test cases based on the program's control flow, data flow, and other structural aspects to ensure that all parts of the code are adequately tested.

### Control Graphs

_Control Graphs_ are a representation of the flow of control in a program. They are used in software testing to visualize the paths that can be taken through the code during execution. Control graphs can help identify areas of the code that may be difficult to test or that may contain hidden bugs.

\vspace{0.5cm}

**\boxed{CONDITIONAL STATEMENTS}**

Given a condition $C$ and two statements $S_1$ and $S_2$, a conditional statement can be represented as:

$$
\text{if } C \text{ then } S_1 \text{ else } S_2
$$

\vspace{0.5cm}

**\boxed{LOOP STATEMENTS}**

Given a condition $C$ and a statement $S$, a loop statement can be represented as:

$$
\text{while } C \text{ do } S
$$

### Statements Coverage

Let $P$ be a program with control flow graph $G = (N, E)$, where $N$ is the set of nodes (statements) and $E$ is the set of edges (transitions). A test set $T$ satisfies the _Statements Coverage_ if and only if, for every node $n \in N$, there exists at least one test $t \in T$ such that the execution of $P$ with input $t$ visits $n$. Formally:

$$
\forall n \in N, \; \exists t \in T : P(t) \text{ visits } n
$$

\vspace{0.5cm}

In simpler terms, every statement in the program must be executed at least once by the tests in the test set, and every node of the corresponding graph is reached at least once.

### Decision Coverage

Let $P$ be a program with control flow graph $G = (N, E)$, where $N$ is the set of nodes (statements) and $E$ is the set of edges (transitions). A test set $T$ satisfies the _Decision Coverage_ if and only if, for every edge $e \in E$, there exists at least one test $t \in T$ such that the execution of $P$ with input $t$ traverses $e$. Formally:

$$
\forall e \in E, \; \exists t \in T : P(t) \text{ traverses } e
$$

\vspace{0.5cm}

In simpler terms, every decision point in the program must be evaluated to both true and false at least once by the tests in the test set, and every arc of the corresponding graph is travelled along at least once.

### Decision-Condition Coverage

Let $P$ be a program with control flow graph $G = (N, E)$, where $N$ is the set of nodes (statements) and $E$ is the set of edges (transitions). A test set $T$ satisfies the _Decision-Condition Coverage_ if and only if, for every decision point $d \in D$ (where $D$ is the set of decision points in $P$), and for every elementary condition $c$ within $d$, there exist tests $t_1, t_2 \in T$ such that:

$$
\begin{align*}
    &P(t_1) \text{ evaluates } c \to true \land P(t_2) \text{ evaluates } c \to false
\end{align*}
$$

Formally:

$$
\forall d \in D, \; \forall c \in \text{Conditions}(d), \; \exists t_1, t_2 \in T : P(t_1) \text{ evaluates } c \text{ to true and } P(t_2) \text{ evaluates } c \text{ to false}
$$

\vspace{0.5cm}

In simpler terms, every decision point in the program evaluates once $true$ and once $false$ as well as every elementary condition therein.

### Paths Coverage

Let $P$ be a program with control flow graph $G = (N, E)$, where $N$ is the set of nodes (statements) and $E$ is the set of edges (transitions). A test set $T$ satisfies the _Paths Coverage_ if and only if, for every possible path $p$ in $G$, there exists at least one test $t \in T$ such that the execution of $P$ with input $t$ follows the path $p$. Formally:

$$
\forall p \in \text{Paths}(G), \; \exists t \in T : P(t) \text{ follows } p
$$

\vspace{0.5cm}

In simpler terms, every path in the control graph must be executed at least once by the tests in the test set.

### Loops Coverage

Let $P$ be a program with control flow graph $G = (N, E)$, where $N$ is the set of nodes (statements) and $E$ is the set of edges (transitions). A test set $T$ satisfies the _Loops Coverage Criterion_, known as _ZOT (Zero One Two) Coverage_, if and only if, for every loop $l \in L$ (where $L$ is the set of loops in $P$), there exists at least one test $t \in T$ such that the execution of $P$ with input $t$ traverses the loop $l$. Formally:

$$
\forall p \in \text{Paths}(G), \; \exists t \in T : P(t) \text{ follows } p
$$

\vspace{0.5cm}

In simpler terms, every path in the control graph must be executed at least once by the tests in the test set.

## Dynamic Analysis

_Dynamic analysis_ is the examination of a program by executing it in a controlled environment to identify runtime errors, performance issues, and other problems that may not be detectable through static analysis.

\vspace{0.5cm}

Well-known dynamic analysis techniques include:

- **Unit Testing:** Involves testing individual components or units of code in isolation to ensure they function correctly.
- **Integration Testing:** Focuses on testing the interactions between different components or modules to ensure they work together as expected.
- **Regression Testing:** Involves retesting the system after changes or updates to ensure that existing functionality has not been adversely affected.

## Testing in Production

Testing in production (TiP) is the practice of running tests on software systems in a live environment, where real users interact with the application. This approach allows developers to identify issues that may not have been detected during pre-production testing phases, as it exposes the software to real-world conditions and usage patterns.

\vspace{0.5cm}

Types of tests in production include:

- **Security Tests:** Focus on identifying vulnerabilities and weaknesses in the system's security measures to protect against potential threats and attacks.
- **Robustness Tests:** Assess the system's ability to handle unexpected inputs, errors, or failures gracefully without crashing or producing incorrect results.
- **Stress Tests:** Involve subjecting the system to extreme workloads to evaluate its performance and stability under high stress conditions.
- **Configuration Tests:** Verify that the system functions correctly across different configurations, settings, and environments.
- **Alpha Tests:** Conducted in-house by developers or testers to identify bugs before releasing the software to external users.
- **Beta Tests:** Involve real users testing the software in a production-like environment to gather feedback and identify issues before the final release.
